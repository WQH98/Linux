###### 一、Linux内核中断处理

1、裸机中断

①、使能中断，初始化相应的寄存器。
②、注册中断处理函数，也就是irqTable数组的指定标号处写入中断服务函数。
③、中断发生以后进入IRQ中断服务函数，在IRQ中断服务函数在数组irqTable里面查找具体的中断处理函数，找到以后执行相应的中断处理函数。

2、Linux中断

①、先知道你要申请的中断对应的中断号。
②、先申请request_irq，此函数会激活中断。
③、如果不用中断了，那就释放掉，使用free_irq。
④、中断处理函数，irqreturn_t(\*irq_handler_t)(int void\*);
⑤、使能和禁止中断、

3、上半部与下半部

①、中断一定要处理的越快越好。
②、上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。
③、下半部：如果中断处理比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。
④、如果要处理的内容不希望被其他中断打断，可以放在上半部、如果要处理的任务对时间敏感，可以放在上半部、如果要处理的任务与硬件有关，可以放在上半部、除了上述三点以外的其他任务，优先考虑放在下半部。
⑤、要使用软中断，要先注册，使用函数open_softirq，注册以后使用raise_sfotirq触发。
⑥、tasklet是利用软中断来实现的另外一种下半部机制，在软中断和tasklet之间，建议使用tasklet。也需要用到上半部，上半部的中断处理函数重点是调用tasklet_schedule。使用步骤是先定义一个tasklet函数，然后初始化函数，重点是设置对应的处理函数。
⑦、工作队列：工作队列是另外一种下半部执行方式，工作队列在进程上下文执行，工作队列将要推后的工作交给一个内核线程去执行，因为工作队列工作在进程上下文，因此工作队列允许睡眠或重新调度。因此如果你要推后的工作可以睡眠那么就可以选择工作队列，否则的话就只能选择软中断或 tasklet。

4、设备树中断节点信息

①、#interrupt-cells指定interrupt的cells数量，也就是属性interrupts。
②、通过函数irq_of_parse_and_map从interrupts属性中获取中断号。
