##### 一、信号的概念

###### 1、基本概念

信号时发生事件时对进程的一种通知机制

###### 2、信号的目的是用来通信的

信号可以由以下情况发出：
	①、硬件发生异常即硬件检测到错误条件并通知内核，随即再由内核发送相应的信号给相关进程。	
	②、用于在终端下输入了能够产生信号的特殊字符。
	③、进程调用 kill()系统调用可将任意信号发送给另一个进程或进程组。
	④、用户可以通过 kill 命令将信号发送给其它进程。
	⑤、发生了软件事件，即当检测到某种软件条件已经发生。

###### 3、信号由谁处理、怎么处理？

进程处理信号的情况有三种：
	①、忽略信号。
	②、捕获信号。
	③、执行系统默认操作。

###### 4、信号是异步的

信号是异步事件的经典实例，产生信号的事件对进程而言是随机出现的，进程无法预测该事件产生的准确时间，进程不能够通过简单地测试一个变量或使用系统调用来判断是否产生了一个信号，这就如同硬件中断事件，程序是无法得知中断事件产生的具体时间，只有当产生中断事件时，才会告知程序、然后打断当前程序的正常执行流程、跳转去执行中断服务函数，这就是异步处理方式。

###### 5、信号本质上是int类型的数字编号

信号本质上是 int 类型的数字编号，这就好比硬件中断所对应的中断号。内核针对每个信号，都给其定义了一个唯一的整数编号，从数字 1 开始顺序展开。

##### 二、信号的分类

###### 1、Linux信号机制基本是从UNIX系统中继承过来的

早期UNIX系统的信号机制比较简单和原始，在实践中暴露出了一些问题：
	①、进程每次处理完信号后，就将对信号的响应设置为系统默认操作
	②、信号可能会丢失

###### 2、可靠信号与不可靠信号

不可靠信号(1~31)：Linux下的不可靠信号的不可靠问题主要指的是信号可能会丢失
可靠信号(34~64)：可靠信号支持排队，不会丢失

###### 3、实时信号与非实时信号

等于可靠信号与不可靠信号。
也可以吧不可靠信号和非实时信号称为标准信号。

##### 三、常见信号介绍

###### 1、SIGINT

当用户在终端按下中断字符（通常是 CTRL + C）时，内核将发送 SIGINT 信号给前台进程组中的每一个进程。该信号的系统默认操作是终止进程的运行。所以通常我们都会使用 CTRL + C 来终止一个占用前台的进程，原因在于大部分的进程会将该信号交给系统去处理，从而执行该信号的系统默认操作。

###### 2、SIGQUIT

当用户在终端按下退出字符（通常是 CTRL + \）时，内核将发送 SIGQUIT 信号给前台进程组中的每一个进程。该信号的系统默认操作是终止进程的运行、并生成可用于调试的核心转储文件。进程如果陷入无限循环、或不再响应时，使用 SIGQUIT 信号就很合适。所以对于一个前台进程，既可以在终端按下中断字符CTRL + C、也可以按下退出字符 CTRL + \来终止，当然前提条件是，此进程会将 SIGINT 信号或 SIGQUIT信号交给系统处理（也就是没有将信号忽略或捕获），进入执行该信号所对应的系统默认操作。

###### 3、SIGILL

如果进程试图执行非法（即格式不正确）的机器语言指令，系统将向进程发送该信号。该信号的系统默认操作是终止进程的运行。

###### 4、SIGABRT

当进程调用 abort()系统调用时（进程异常终止），系统会向该进程发送 SIGABRT 信号。该信号的系统默认操作是终止进程、并生成核心转储文件。

###### 5、SIGBUS

产生该信号（总线错误，bus error）表示发生了某种内存访问错误。该信号的系统默认操作是终止进程。

###### 6、SIGFPE

该信号因特定类型的算术错误而产生，譬如除以 0。该信号的系统默认操作是终止进程。

###### 7、SIGKILL

此信号为“必杀（sure kill）”信号，用于杀死进程的终极办法，此信号无法被进程阻塞、忽略或者捕获，故而“一击必杀”，总能终止进程。使用 SIGINT 信号和 SIGQUIT 信号虽然能终止进程，但是前提条件是该进程并没有忽略或捕获这些信号，如果使用 SIGINT 或 SIGQUIT 无法终止进程，那就使用“必杀信号”SIGKILL 吧。Linux 下有一个 kill 命令，kill 命令可用于向进程发送信号，我们会使用"kill -9 xxx"命令来终止一个进程（xxx 表示进程的 pid），这里的-9 其实指的就是发送编号为 9 的信号，也就是 SIGKILL 信号。

###### 8、SIGUSR1

该信号和 SIGUSR2 信号供程序员自定义使用，内核绝不会为进程产生这些信号，在我们的程序中，可以使用这些信号来互相通知事件的发生，或是进程彼此同步操作。该信号的系统默认操作是终止进程。

###### 9、SIGSEGV

这一信号非常常见，当应用程序对内存的引用无效时，操作系统就会向该应用程序发送该信号。引起对内存无效引用的原因很多，C 语言中引发这些事件往往是解引用的指针里包含了错误地址（譬如，未初始化的指针），或者传递了一个无效参数供函数调用等。该信号的系统默认操作是终止进程。

###### 10、SIGUSR2

与 SIGUSR1 信号相同。

###### 11、SIGPIPE

涉及到管道和 socket，当进程向已经关闭的管道、FIFO 或套接字写入信息时，那么系统将发送该信号给进程。该信号的系统默认操作是终止进程。

###### 12、SIGALRM

与系统调用 alarm()或 setitimer()有关，应用程序中可以调用 alarm()或 setitimer()函数来设置一个定时器，当定时器定时时间到，那么内核将会发送 SIGALRM 信号给该应用程序，关于 alarm()或 setitimer()函数的使用，后面将会进行讲解。该信号的系统默认操作是终止进程。

###### 13、SIGTERM

这是用于终止进程的标准信号，也是 kill 命令所发送的默认信号（kill xxx，xxx 表示进程 pid），有时我们会直接使用"kill -9 xxx"显式向进程发送 SIGKILL 信号来终止进程，然而这一做法通常是错误的，精心设计的应用程序应该会捕获 SIGTERM 信号、并为其绑定一个处理函数，当该进程收到 SIGTERM 信号时，会在处理函数中清除临时文件以及释放其它资源，再而退出程序。如果直接使用 SIGKILL 信号终止进程，从而跳过了 SIGTERM 信号的处理函数，通常 SIGKILL 终止进程是不友好的方式、是暴力的方式，这种方式应该作为最后手段，应首先尝试使用 SIGTERM，实在不行再使用最后手段 SIGKILL。

###### 14、SIGCHLD

当父进程的某一个子进程终止时，内核会向父进程发送该信号。当父进程的某一个子进程因收到信号而停止或恢复时，内核也可能向父进程发送该信号。注意这里说的停止并不是终止，你可以理解为暂停。该信号的系统默认操作是忽略此信号，如果父进程希望被告知其子进程的这种状态改变，则应捕获此信号。

###### 15、SIGCLD

与 SIGCHLD 信号同义。

###### 16、SIGCONT

将该信号发送给已停止的进程，进程将会恢复运行。当进程接收到此信号时并不处于停止状态，系统默认操作是忽略该信号，但如果进程处于停止状态，则系统默认操作是使该进程继续运行。

###### 17、SIGSTOP

这是一个“必停”信号，用于停止进程（注意停止不是终止，停止只是暂停运行、进程并没有终止），应用程序无法将该信号忽略或者捕获，故而总能停止进程。

###### 18、SIGTSTP

这也是一个停止信号，当用户在终端按下停止字符（通常是 CTRL + Z），那么系统会将 SIGTSTP 信号发送给前台进程组中的每一个进程，使其停止运行。

###### 19、SIGXCPU

当进程的 CPU 时间超出对应的资源限制时，内核将发送此信号给该进程。

###### 20、SIGVTALRM

应用程序调用 setitimer()函数设置一个虚拟定时器，当定时器定时时间到时，内核将会发送该信号给进程。

###### 21、SIGWINCH

在窗口环境中，当终端窗口尺寸发生变化时（譬如用户手动调整了大小，应用程序调用 ioctl()设置了大小等），系统会向前台进程组中的每一个进程发送该信号。

###### 22、SIGPOLL/SIGIO

这两个信号同义。这两个信号将会在高级 IO 章节内容中使用到，用于提示一个异步 IO 事件的发生，譬如应用程序打开的文件描述符发生了 I/O 事件时，内核会向应用程序发送 SIGIO 信号。

###### 23、SIGSYS

如果进程发起的系统调用有误，那么内核将发送该信号给对应的进程。

##### 四、进程对信号的处理

###### 1、signal函数

```c
/*
	系统调用 signal()，signal()函数是 Linux 系统下设置信号处理方式最简单的接口，可将信号的处理方式设置为捕获信号、忽略信号以及系统默认操作
	signum：此参数指定需要进行设置的信号，可使用信号名（宏）或信号的数字编号，建议使用信号名。
	handler：sig_t 类型的函数指针，指向信号对应的信号处理函数，当进程接收到信号后会自动执行该处理函数；参数 handler 既可以设置为用户自定义的函数，也就是捕获信号时需要执行的处理函数，也可以设置为 SIG_IGN 或 SIG_DFL，SIG_IGN 表示此进程需要忽略该信号，SIG_DFL 则表示设置为系统默认操作。
	sig_t 函数指针的 int 类型参数指的是，当前触发该函数的信号，可将多个信号绑定到同一个信号处理函数上，此时就可通过此参数来判断当前触发的是哪个信号
	返回值：此函数的返回值也是一个 sig_t 类型的函数指针，成功情况下的返回值则是指向在此之前的信号处理函数；如果出错则返回 SIG_ERR，并会设置 errno。
*/
#include "signal.h"

typedef void (*sig_t)(int);
sig_t signal(int signum, sig_t handler);
```

###### 2、sigaction函数

```c
/*
	sigaction()允许单独获取信号的处理函数而不是设置，并且还可以设置各种属性对调用信号处理函数时的行为施以更加精准的控制 
	signum：需要设置的信号，除了 SIGKILL 信号和 SIGSTOP 信号之外的任何信号。
	act：act 参数是一个 struct sigaction 类型指针，指向一个 struct sigaction 数据结构，该数据结构描述了信号的处理方式，稍后介绍该数据结构；如果参数 act 不为 NULL，则表示需要为信号设置新的处理方式；如果参数 act 为 NULL，则表示无需改变信号当前的处理方式。
	oldact：oldact 参数也是一个 struct sigaction 类型指针，指向一个 struct sigaction 数据结构。如果参数oldact 不为 NULL，则会将信号之前的处理方式等信息通过参数 oldact 返回出来；如果无意获取此类信息，那么可将该参数设置为 NULL。
	返回值：成功返回 0；失败将返回-1，并设置 errno。
*/
#include "signal.h"

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

##### 五、向进程发送信号

###### 1、kill()函数

```c
/*
	kill()系统调用可将信号发送给指定的进程或进程组中的每一个进程
	pid：参数 pid 为正数的情况下，用于指定接收此信号的进程 pid；除此之外，参数 pid 也可设置为 0 或-1 以及小于-1 等不同值，稍后给说明。
	sig：参数 sig 指定需要发送的信号，也可设置为 0，如果参数 sig 设置为 0 则表示不发送信号，但任执行错误检查，这通常可用于检查参数 pid 指定的进程是否存在。
	返回值：成功返回 0；失败将返回-1，并设置 errno。
*/
#include "sys/types.h"
#include "signal.h"

int kill(pid_t pid, int sig);
```

###### 2、raise()函数

```c
/*
	有时进程需要向自身发送信号，raise()函数可用于实现这一要求
	sig：需要发送的信号。
	返回值：成功返回 0；失败将返回非零值。
	raise()其实等价于：kill(getpid(), sig);
*/
#include "signal.h"

int raise(int sig);
```

##### 六、alarm和pause函数

###### 1、alarm函数

```c
/*
	使用 alarm()函数可以设置一个定时器（闹钟），当定时器定时时间到时，内核会向进程发送 SIGALRM信号
	seconds：设置定时时间，以秒为单位；如果参数 seconds 等于 0，则表示取消之前设置的 alarm 闹钟。
	返回值：如果在调用 alarm()时，之前已经为该进程设置了 alarm 闹钟还没有超时，则该闹钟的剩余值作为本次 alarm()函数调用的返回值，之前设置的闹钟则被新的替代；否则返回 0。
*/
#include "unistd.h"

unsigned int alarm(unsigned int seconds);
```

###### 2、pause函数

```c
/*
	pause()系统调用可以使得进程暂停运行、进入休眠状态，直到进程捕获到一个信号为止，只有执行了信号处理函数并从其返回时，pause()才返回，在这种情况下，pause()返回-1，并且将 errno 设置为 EINTR。
*/
#include "unistd.h"

int pause(void);
```

##### 七、信号集

###### 1、初始化信号集

```c
/*
	sigemptyset()和 sigfillset()用于初始化信号集。sigemptyset()初始化信号集，使其不包含任何信号；而sigfillset()函数初始化信号集，使其包含所有信号（包括所有实时信号）
	set：指向需要进行初始化的信号集变量。
	返回值：成功返回 0；失败将返回-1，并设置 errno。
*/
#include "signal.h"

int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
```

###### 2、向信号集中添加/删除信号

```c
/*
	分别使用 sigaddset()和 sigdelset()函数向信号集中添加或移除一个信号
	set：指向信号集。
	signum：需要添加/删除的信号。
	返回值：成功返回 0；失败将返回-1，并设置 errno。
*/
#include "signal.h"

int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);
```

###### 3、测试信号是否在信号集中

```c
/*
	使用 sigismember()函数可以测试某一个信号是否在指定的信号集中
	set：指定信号集。
	signum：需要进行测试的信号。
	返回值：如果信号 signum 在信号集 set 中，则返回 1；如果不在信号集 set 中，则返回 0；失败则返回-1，并设置 errno。
*/
#include "signal.h"

int sigismember(const sigset_t *set, int signum);
```

##### 八、信号掩码

###### 1、信号掩码的概念

内核为每一个进程维护了一个信号掩码（其实就是一个信号集），即一组信号。当进程接收到一个属于信号掩码中定义的信号时，该信号将会被阻塞、无法传递给进程进行处理，那么内核会将其阻塞，直到该信号从信号掩码中移除，内核才会把该信号传递给进程从而得到处理。

###### 2、向信号掩码中添加信号的几种方式

①、当应用程序调用 signal()或 sigaction()函数为某一个信号设置处理方式时，进程会自动将该信号添加到信号掩码中，这样保证了在处理一个给定的信号时，如果此信号再次发生，那么它将会被阻塞；当然对于 sigaction()而言，是否会如此，需要根据 sigaction()函数是否设置了 SA_NODEFER 标志而定；当信号处理函数结束返回后，会自动将该信号从信号掩码中移除。
②、使用 sigaction()函数为信号设置处理方式时，可以额外指定一组信号，当调用信号处理函数时将该组信号自动添加到信号掩码中，当信号处理函数结束返回后，再将这组信号从信号掩码中移除；通过 sa_mask 参数进行设置。
③、除了以上两种方式之外，还可以使用 sigprocmask()系统调用，随时可以显式地向信号掩码中添加/移除信号。

###### 3、sigprocmask函数

```c
/*
	how：参数 how 指定了调用函数时的一些行为。
	set：将参数 set 指向的信号集内的所有信号添加到信号掩码中或者从信号掩码中移除；如果参数 set 为NULL，则表示无需对当前信号掩码作出改动。
	oldset：如果参数 oldset 不为 NULL，在向信号掩码中添加新的信号之前，获取到进程当前的信号掩码，存放在 oldset 所指定的信号集中；如果为 NULL 则表示不获取当前的信号掩码。
	返回值：成功返回 0；失败将返回-1，并设置 errno。
	参数 how 可以设置为以下宏：
		SIG_BLOCK：将参数 set 所指向的信号集内的所有信号添加到进程的信号掩码中。换言之，将信号掩码设置为当前值与 set 的并集。
		SIG_UNBLOCK：将参数 set 指向的信号集内的所有信号从进程信号掩码中移除。
		SIG_SETMASK：进程信号掩码直接设置为参数 set 指向的信号集。
*/
#include "signal.h"

int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

##### 九、实时信号

###### 1、sigpending函数

```c
/*
	如果进程当前正在执行信号处理函数，在处理信号期间接收到了新的信号，如果该信号是信号掩码中的成员，那么内核会将其阻塞，将该信号添加到进程的等待信号集（等待被处理，处于等待状态的信号）中，为了确定进程中处于等待状态的是哪些信号，可以使用 sigpending()函数获取。
	set：处于等待状态的信号会存放在参数 set 所指向的信号集中。
	返回值：成功返回 0；失败将返回-1，并设置 errno。
*/
#include "signal.h"

int sigpending(sigset_t *set);
```

###### 2、实时信号的编号

Linux 内核定义了 31 个不同的实时信号，信号编号范围为 34~64，使用 SIGRTMIN 表示编号最小的实时信号，使用 SIGRTMAX 表示编号最大的实时信号，其它信号编号可使用这两个宏加上一个整数或减去一个整数。

###### 3、实时信号的优势

①、实时信号的信号范围有所扩大，可应用于应用程序自定义的目的，而标准信号仅提供了两个信号可用于应用程序自定义使用：SIGUSR1 和 SIGUSR2。
②、内核对于实时信号所采取的是队列化管理。如果将某一实时信号多次发送给另一个进程，那么将会多次传递此信号。相反，对于某一标准信号正在等待某一进程，而此时即使再次向该进程发送此信号，信号也只会传递一次。
③、当发送一个实时信号时，可为信号指定伴随数据（一整形数据或者指针值），供接收信号的进程在它的信号处理函数中获取。
④、不同实时信号的传递顺序得到保障。如果有多个不同的实时信号处于等待状态，那么将率先传递具有最小编号的信号。换言之，信号的编号越小，其优先级越高，如果是同一类型的多个信号在排队，那么信号（以及伴随数据）的传递顺序与信号发送来时的顺序保持一致。

###### 4、如何使用实时信号

发送进程使用 sigqueue()系统调用向另一个进程发送实时信号以及伴随数据。
接收实时信号的进程要为该信号建立一个信号处理函数，使用sigaction函数为信号建立处理函数，并加入 SA_SIGINFO，这样信号处理函数才能够接收到实时信号以及伴随数据，也就是要使用sa_sigaction 指针指向的处理函数，而不是 sa_handler，当然允许应用程序使用 sa_handler，但这样就不能获取到实时信号的伴随数据了。

```c
/*
	pid：指定接收信号的进程对应的 pid，将信号发送给该进程。
	sig：指定需要发送的信号。与 kill()函数一样，也可将参数 sig 设置为 0，用于检查参数 pid 所指定的进程是否存在。
	value：参数 value 指定了信号的伴随数据，union sigval 数据类型。
	返回值：成功将返回 0；失败将返回-1，并设置 errno。
*/
#include "signal.h"

int sigqueue(pid_t pid, int sig, const union sigval value);
```

##### 十、abort异常终止进程

###### 1、进程的终止分为两类

正常终止：
①、在main函数中通过return语句退出程序
②、在程序当中调用库函数或者系统调用终止进程，譬如exit()、\_Exit()、\_exit()

异常终止：
①、被信号终止
②、调用abort信号，SIGABRT

###### 2、abort函数的要点

①、解除对SIGABRT信号的阻塞
②、向本进程发送SIGABRT信号，导致进程异常终止

###### 3、在程序中忽略\捕获了SIGABRT信号

①、将SIGABRT信号的处理方式重置为系统默认操作
②、再次向本进程发送SIGABRT信号
③、调用abort函数一定会终止进程的运行