##### 1、进程的概念

###### 1、何为进程？

进程是一个应用程序的执行实例，也就是系统中正在运行的应用程序，程序一旦运行就是进程，进程是一个动态过程，它是程序的一次运行过程，而非静态文件。进程和程序是两个完全不同的概念，我们通常所说的程序指的是可执行程序，也就是可执行文件，说明程序本质上是一个文件，文件是一种静态的概念，文件存储在磁盘中，文件本身不会对系统产生任何影响。而进程指的是正在运行的程序，它强调的是运行中，所以进程是一种动态的概念，程序运行之后会对系统环境产生一定的影响。
同一个程序可以被运行多次，从而产生多个不同的进程，可以把进程理解为程序的实例化对象，程序被执行一次就表示实例化了一次，被执行多次就表示实例化了多次，产生了多个不同的实例化对象，也就是多个不同的进程。
进程的生命周期就是从程序启动到程序退出这段时间。

###### 2、进程号（process ID）

Linux系统下的每一个进程都有一个进程号（process ID，简称PID），进程号是一个正数，用于唯一标识系统中的某一个进程。 

```c
/*
	在应用程序中，可通过系统调用 getpid()来获取本进程的进程号
	函数返回值为 pid_t 类型变量，便是对应的进程号。
*/
#include "sys/types.h"
#include "unistd.h"

pid_t getpid(void);
```

###### 3、main函数由谁调用？

在运行main函数之前，还会运行一段引导代码，最终由这段引导代码调用main函数。这段引导代码并不需要我们自己编写，而是在编译、链接我们的应用的时候由链接器将这段引导代码链接到我们的应用程序中，构成最终的可执行文件，也就是最终的程序。

###### 4、进程如何终止？

正常终止： 
①、在main函数中通过return语句退出程序 
②、在程序当中调用库函数或者系统调用终止进程，譬如exit()、_Exit()、_exit()

异常终止： 
①、被信号终止 
②、调用abort信号，SIGABRT

##### 二、终止进程：exit()和\_exit()

###### 1、exit、\_exit的用法

```c
/*
	两个函数都用来终止进程的运行
	status：用来表示进程终止时的状态，通常0表示正常终止，非零值表示非正常终止，譬如0
*/
void _exit(int status);
void exit(int status);
```

###### 2、exit、\_exit之间的区别

①、exit是库函数，\_exit是一个系统调用，所需要包含的头文件不一样
②、这两个函数的最终目的相同，都是终止进程，但是在终止进程之前需要做一些处理，这些处理工作这两个函数是不一样的。

![exit和_exit的区别](/home/wqh/Project/Linux/Linux_C/chapter_9/documents/01_进程.assets/exit和_exit的区别.png)

有一些终止进程的情况是不会刷新stdio缓冲的：
①、\_exit()和\_Exit()
②、被信号终止的情况

###### 3、exit和return之间的区别

①、exit是一个库函数，return是C语言的语句。
②、exit函数最终会进入内核，把控制权交给内核，最终由内核去终止进程。执行return并不会进入到内核，它只是一个main函数返回，返回到它的上层调用，把控制权交给它的上层调用，最终由上层调用终止进程。
③、return终止进程也会调用终止处理函数，并且会刷新IO缓冲。

###### 4、exit和abort之间的区别

①、exit用于正常终止进程，abort用于异常终止进程。正常终止在终止进程之前会执行一些清理工作，异常终止并不会执行这些清理工作，它是直接终止进程的，直接执行SIGABRT信号的系统默认处理操作，终止进程的运行。

###### 5、总结

##### 三、进程的环境变量

###### 1、环境变量的概念

环境变量指的是进程运行环境中定义的一些变量，类似于进程的全局变量，可以在程序中的任何地方获取，只需要申明即可，但是与全局变量不同的是，这些环境变量可以被其子进程所继承，也就是具有继承性。
环境变量的本质当然还是变量，不过这些变量没有类型，他们都是以字符串的形式存储在一个字符串数组中，通常把这个字符串数组称为环境表。
数组中的每一个字符串（也就是环境变量）都是以"name = value"这种形式定义的，name表示变量的名称，value表示变量的值。

###### 2、常见的环境变量

PATH：用于指定可执行程序的搜索路径
HOME：用于指定当前用户的家目录
LOGNAME：用于指定当前登录的用户
HOSTNAME：用于指定主机名
SHELL：用于指定当前的shell解析器
PWD：用于指定进程的当前工作目录

###### 3、环境变量的组织形式

这些环境变量都是以字符串的形式存储在一个字符串数组中，把这个字符串数组称为环境表，环境表中的每一个字符串都是按照"name = value"这种格式定义的，name表示变量名称，value表示变量的值。这个字符串数组以NULL结尾。

###### 4、应用程序中获取环境变量

每一个应用程序都有一组环境变量，进程在创建的时候，它的环境变量是从其父进程中继承过来的。

4.1、通过environ变量获取
这个变量是一个全局变量，我们可以在程序中直接使用，只需要申明即可。environ 变量其实是一个指针，它指向了一个字符串数组，这个字符串数组就是进程的环境表。

```c
extern char **environ;
```

4.2、通过main函数的参数获取

```c
int main(void);
int main(int argc, char *argv[]);
int main(int argc, char *argv[], char *env[]);
```

第三个参数env其实就是进程的环境表。

4.3、通过getenv获取

```c
/*
	如果只想要获取某个指定的环境变量，可以使用库函数 getenv()
	name：指定获取的环境变量名称。
	返回值：如果存放该环境变量，则返回该环境变量的值对应字符串的指针；如果不存在该环境变量，则返回 NULL。
	需要注意的是，我们不应该去修改该函数返回的字符串，如果修改了这个字符串也就意味着修改了该环境变量的值。如果要修改变量的值，我们可以通过一些库函数去实现。
*/
#include "stdlib.h" 

char *getenv(const char *name);
```

###### 5、添加、修改、删除环境变量

既然环境变量的本质是变量，对于变量，自然可以读取变量也可以修改变量，当然也可以在环境表中添加新的环境变量。

5.1、通过putenv添加、修改环境变量

```c
/*
	putenv()函数可向进程的环境变量数组中添加一个新的环境变量，或者修改一个已经存在的环境变量对应的值
	string：参数 string 是一个字符串指针，指向 name=value 形式的字符串。
	返回值：成功返回 0；失败将返回非 0 值，并设置 errno。
	需要注意的是，调用该函数之后，参数string所指向的字符串将成为环境变量的一部分，也就是说，进程的环境表中某个元素会指向该字符串，因为这个函数内部不会复制一份string字符串，而是直接使用它。所以调用putenv函数之后，不要去修改string所指定的字符串，否则将会修改到环境变量，所以由此可知，这个string参数不应该是自动变量，因为自动变量的生命周期是函数内部，除了函数之后便不再有效了。譬如可以使用malloc分配堆内存，或者直接使用全局变量。
*/
#include "stdlib.h"

int putenv(char *string);
```

5.2、通过setenv添加、修改环境变量

```c
/*
	setenv()函数可以替代 putenv()函数，用于向进程的环境变量列表中添加一个新的环境变量或修改现有环境变量对应的值
	name：需要添加或修改的环境变量名称。
	value：环境变量的值。
	overwrite：若参数 name 标识的环境变量已经存在，在参数 overwrite 为 0 的情况下，setenv()函数将不改变现有环境变量的值，也就是说本次调用没有产生任何影响；如果参数 overwrite 的值为非 0，若参数 name标识的环境变量已经存在，则覆盖，不存在则表示添加新的环境变量。
	返回值：成功返回 0；失败将返回-1，并设置 errno。
*/
#include "stdlib.h"

int setenv(const char *name, const char *value, int overwrite);
```

setenv跟seyenv函数的两个区别：
①、putenv函数内部不会备份用户传入的字符串参数，而是直接使用这个字符串作为其环境变量；但是setenv函数内部会将用户传入的字符串拷贝到自己的缓冲区中。
②、在环境变量存在的情况下，putenv是直接强制修改该变量的值；而对应setenv函数，用户可以通过第三个参数控制是否修改现有环境变量的值。

5.3、执行程序时添加环境变量
在./执行程序之前，添加name=value。比如name=value ./test

5.4、通过unset删除环境变量

```c
/*
	unsetenv()函数可以从环境变量表中移除参数 name 标识的环境变量
*/
#include "stdlib.h"

int unsetenv(const char *name);
```

###### 6、清空环境变量

6.1、直接将envrion设置为NULL
6.2、通过clearenv清空环境变量

##### 四、创建子进程

###### 1、所有进程都是由其父进程所创建出来的

Linux系统中的所有进程都是由其父进程所创建出来的，譬如我们在终端下执行某个应用程序，这个程序启动以后就是一个进程，这个进程就是由它的父进程（也就是这个shell进程）所创建出来的。
shell进程就是shell解析器（shell解析器由很多种，譬如bash、sh等），所谓解析器就是解析用户输入的各种命令，然后做出相应的响应，执行相应的程序。 
最原始的父进程就是init进程，init进程的PID是1，它是所有进程的父进程。

###### 2、进程空间的概念

在LInux系统中，进程与进程之间、进程与内核之间都是相互隔离的，各自在自己的进程空间中运行（内核就是在自己的内核空间中运行）；一个进程不能读取或修改另一个进程或内核的内存数据，这样提高了系统的安全性和稳定性。
新进程被创建出来之后，便是一个独立的进程，拥有自己独立的进程空间，拥有自己唯一的进程号（PID），拥有自己独立的PCB（进程控制块），新进程会被内核同等调度执行，参与到系统调用中。

###### 3、fork创建子进程

应用程序中可以调用fork系统调用来创建一个新的进程，被创建出来的新进程称为子进程，调用fork函数的进程称为父进程，这两个进程之间就是父子关系。
子进程与父进程之间的这种关系被称为父子进程关系，父子进程关系相比于普通的进程间关系多多少少存在一些关联。

```c
/*
	一个现有的进程可以调用 fork()函数创建一个新的进程，调用 fork()函数的进程称为父进程，由 fork()函数创建出来的进程被称为子进程（child process）
*/
#include "unistd.h"

pid_t fork(void);
```

###### 4、如何理解fork系统调用

4.1、一次fork调用会产生两次返回值
也就是说调用一次fork函数，会产生两次返回值。因为fork调用会创建一个新的进程，这个新的进程就是子进程，也就是说，在fork调用之后，会存在两个进程，一个子进程，一个父进程。所以会有两次返回值，子进程会返回一次，父进程也会返回一次。并且这两次的返回值是不一样的，分别会返回一个0和大于0的整数，这个0便是子进程的返回值，大于0的整数则是父进程的返回值。所以我们可以通过返回值来判断当前是父进程还是子进程。这个大于0的整数就是子进程的PID。

4.2、fork创建了一个与原来进程几乎相同的进程
其实子进程是父进程的一个副本，fork函数是以复制的方式创建子进程，子进程几乎完全复制了父进程，譬如子进程会拷贝父进程的数据段、堆、栈，并且拷贝父进程打开的所有文件描述符，父进程与子进程并不会共享这些存储空间，这是子进程对父进程相应部分存储空间的完全复制，执行fork之后，子进程和父进程各自在自己的进程空间中运行，每个进程均可修改各自的栈数据以及堆栈中的变量，而不会影响另一个进程。

4.3、子进程从fork调用返回后的代码开始执行
虽然子进程和父进程运行在不同的进程空间中，但是他们执行的却是同一个程序。但是需要注意，子进程运行的是fork调用之后的代码，并不会执行fork调用之前的代码。

##### 五、父子进程间的文件共享

###### 1、父子进程间文件的共享方式

文件共享：多个进程、多个线程对同一文件进行读写操作。

![父子进程间的文件共享](/home/wqh/Project/Linux/Linux_C/chapter_9/documents/01_进程.assets/父子进程间的文件共享.png)

子进程对拷贝父进程打开的所有文件描述符（继承）。父子进程中的fd0...使用的是同一个读写指针。

##### 六、父子进程间的竞争关系

###### 1、fork之后父进程和子进程谁先运行？

调用 fork()之后，子进程成为了一个独立的进程，可被系统调度运行，而父进程也继续被系统调度运行，这里出现了一个问题，调用 fork 之后，无法确定父、子两个进程谁将率先访问 CPU，也就是说无法确认谁先被系统调用运行（在多核处理器中，它们可能会同时各自访问一个 CPU），这将导致谁先运行、谁后运行这个顺序是不确定的。

##### 七、监视子进程

在很多应用程序的设计中，父进程需要知道子进程于何时被终止，并且需要知道子进程的终止状态信息，是正常终止、还是异常终止亦或者被信号终止等，意味着父进程会对子进程进行监视。

子进程的状态改变包括哪些？
①、子进程终止
②、子进程因为收到停止信号而停止运行，SIGSTOP、SIGTSTP
③、子进程在停止状态下因为收到回复信号而恢复运行，SIGCONT
当子进程发生以上三种状态改变的任何一种时，内核就会向父进程发送SIGCHLD信号

###### 1、wait函数

```c
/*
	对于许多需要创建子进程的进程来说，有时设计需要监视子进程的终止时间以及终止时的一些状态信息，在某些设计需求下这是很有必要的。系统调用 wait()可以等待进程的任一子进程终止，同时获取子进程的终止状态信息。
	status：参数 status 用于存放子进程终止时的状态信息，参数 status 可以为 NULL，表示不接收子进程终止时的状态信息。
	返回值：若成功则返回终止的子进程对应的进程号；失败则返回-1。
	wait函数的两个作用：
		1、监视子进程为什么终止，以及获取子进程终止时的状态信息
		2、回收子进程的一些资源，俗称为子进程收尸
*/
#include "sys/types.h"
#include "sys/wait.h"

pid_t wait(int *status);
```

###### 2、waitpid函数

使用 wait()系统调用存在着一些限制，这些限制包括如下：
	①、如果父进程创建了多个子进程，使用 wait()将无法等待某个特定的子进程的完成，只能按照顺序等待下一个子进程的终止，一个一个来、谁先终止就先处理谁；
	②、如果子进程没有终止，正在运行，那么 wait()总是保持阻塞，有时我们希望执行非阻塞等待，是否有子进程终止，通过判断即可得知；
	③、使用 wait()只能发现那些被终止的子进程，对于子进程因某个信号（譬如 SIGSTOP 信号）而停止（注意，这里停止指的暂停运行），或是已停止的子进程收到 SIGCONT 信号后恢复执行的情况就无能为力了。

```c
/*
	pid：参数 pid 用于表示需要等待的某个具体子进程，关于参数 pid 的取值范围如下：
		⚫ 如果 pid 大于 0，表示等待进程号为 pid 的子进程；
		⚫ 如果 pid 等于 0，则等待与调用进程（父进程）同一个进程组的所有子进程；
		⚫ 如果 pid 小于-1，则会等待进程组标识符与 pid 绝对值相等的所有子进程；
		⚫ 如果 pid 等于-1，则等待任意子进程。wait(&status)与 waitpid(-1, &status, 0)等价。
	status：与 wait()函数的 status 参数意义相同。
	options：位掩码，可以包含0个或多个标志。
	返回值：返回值与 wait()函数的返回值意义基本相同，在参数 options 包含了 WNOHANG 标志的情况下，返回值会出现 0。
*/
#include "sys/types.h"
#include "sys/wait.h"

pid_t waitpid(pid_t pid, int *status, int options);
```

###### 3、waitid函数

##### 八、SIGCHLD信号

子进程的状态改变包括哪些？
①、子进程终止 
②、子进程因为收到停止信号而停止运行，SIGSTOP、SIGTSTP
③、子进程在停止状态下因为收到回复信号而恢复运行，SIGCONT
当子进程发生以上三种状态改变的任何一种时，内核就会向父进程发送SIGCHLD信号
我们可以为SIGCHLD信号绑定一个信号处理函数，然后在信号处理函数中调用wait或waitpid函数子进程或做出相应处理

###### 1、SIGCHLD信号介绍

使用SIGCHLD信号回收子进程需要注意一个问题：当调用信号处理函数的时候，会暂时将当前正要处理的信号添加到进程的信号掩码中，这样一来，当SIGCHLD信号处理函数正在为某一个已经终止的子进程收尸时，如果此时相继有两个子进程终止了，也就是会产生两次SIGCHLD信号，但是会有一次SIGCHLD信号会被丢失，也就是说父进程最终也只能接收到一次SIGCHLD信号，那么就会导致漏掉一个，导致有一个已经终止的子进程未被回收。

###### 2、使用异步方式来回收子进程：SIGCHLD信号处理函数

##### 九、僵尸进程与孤儿进程

###### 1、子进程和父进程谁先禁止？

###### 2、孤儿进程

父进程先于子进程终止，那么也就意味着此时子进程成为了一个“孤儿”，我们把这种子进程称为孤儿进程。

###### 3、僵尸进程

当子进程终止之后，父进程没有去回收子进程（调用wait/waitpidwaitid等函数回收），那么在这种情况下，子进程因为没人给它收尸，所以就会“曝尸荒野”，导致这个子进程就变成了一个僵尸进程。
僵尸进程表示此进程并未被系统彻底删除，他还会占用一些系统资源，如果系统中存在大量的僵尸进程，他们势必会填满内核进程表，从而阻碍新进程的创建。
需要注意的是，僵尸进程无法通过信号将其删除，譬如一击必杀信号；因为僵尸进程本来就是已经终止的进程，只是还未被回收而已。只要它的父进程一直不去回收它，这个僵尸进程就会一直存在系统中。
在这种情况下，想要清除这个僵尸进程，只能将其父进程杀死或者等待其父进程终止，当其父进程终止之后，init进程就会接管这些僵尸进程，init进程将自动称为这些僵尸进程的父进程（也就是养父），那么init进程就会去回收这些僵尸进程，将它们彻底从系统中删除。

##### 十、执行新程序

在终端下执行某个程序，譬如./test，在程序启动之后就是一个进程了，这个进程就是由它的父进程shell进程所创建出来的。在这种情况下，shell父进程执行的就是bash程序，而子进程执行的是test程序。这样子进程和父进程运行的不是同一个程序。譬如通过fork函数创建了一个子进程，所以这个子进程也是运行父进程的程序，当这个子进程启动之后，它可以通过一些手段（调用库函数或者系统调用）用一个新程序去替换这个test程序，然后执行这个新的程序，从这个新程序的main函数开始运行。

###### 1、execve系统调用

```c
/*
	系统调用 execve()可以将新程序加载到某一进程的内存空间，通过调用 execve()函数将一个外部的可执行文件加载到进程的内存空间运行，使用新的程序替换旧的程序，而进程的栈、数据、以及堆数据会被新程序的相应部件所替换，然后从新程序的 main()函数开始执行。
	filename：参数 filename 指向需要载入当前进程空间的新程序的路径名，既可以是绝对路径、也可以是相对路径。
	argv：参数 argv 则指定了传递给新程序的命令行参数。是一个字符串数组，该数组对应于 main(int argc, char *argv[])函数的第二个参数 argv，且格式也与之相同，是由字符串指针所组成的数组，以 NULL 结束。argv[0]对应的便是新程序自身路径名。
	envp：参数 envp 也是一个字符串指针数组，指定了新程序的环境变量列表，参数 envp 其实对应于新程序的 environ 数组，同样也是以 NULL 结束，所指向的字符串格式为 name=value。
	返回值：execve 调用成功将不会返回；失败将返回-1，并设置 errno。
*/
#include "unistd.h"

int execve(const char *filename, char *const argv[], char *const envp[]);
```

###### 2、exec族库函数

###### 3、system库函数

```c
/*
	使用 system()函数可以很方便地在我们的程序当中执行任意 shell 命令
	command：参数 command 指向需要执行的 shell 命令，以字符串的形式提供，譬如"ls -al"、"echo HlloWorld"等。
	返回值：
		①、当参数 command 为 NULL，如果 shell 可用则返回一个非 0 值，若不可用则返回 0；针对一些非UNIX 系统，该系统上可能是没有 shell 的，这样就会导致 shell 不可能；如果 command 参数不为NULL，则返回值从以下的各种情况所决定。	
        ②、如果无法创建子进程或无法获取子进程的终止状态，那么 system()返回-1。
        ③、如果子进程不能执行 shell，则 system()的返回值就好像是子进程通过调用_exit(127)终止了。
        ④、如果所有的系统调用都成功，system()函数会返回执行 command 的 shell 进程的终止状态。
*/
#include "stdlib.h"

int system(const char *command);
```

